"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GenericNedbDataService = void 0;
const IdHelper_1 = require("../../itf/generic/IdHelper");
const errorWithStatus_1 = require("../../../error/errorWithStatus");
const db_connections_1 = require("../../db-connections");
class GenericNedbDataService {
    //collectionName must be  replaced/override in subclass:
    // idHelper may be replaced/override in subclass:
    //by default _id (auto generated by mongoDB)
    //may be overrided by static _id (copy_or_renaming of .num or .code)
    constructor(connectionName, collectionName, idHelper = new IdHelper_1.Auto_IdHelper()) {
        this.connectionName = connectionName;
        this.collectionName = collectionName;
        this.idHelper = idHelper;
    }
    //nedBMap() = utility function for accessing NeDB connectionMap initialized in myAppConnectionMap
    nedBMap() {
        let myNedbConnectionMap = db_connections_1.myAppConnectionMap.getConnection(this.connectionName);
        return myNedbConnectionMap.currentDb();
    }
    //nedbForCollectionOrStore(storeName) = utility function for accessing NeDB connection (for a specific store/collection)
    //in myNedbConnectionMap initialized in myAppConnectionMap
    nedbForCollectionOrStore(storeName = "default") {
        let neDbMap = this.nedBMap();
        return new Promise((resolve, reject) => {
            let myNedbConnection = neDbMap.get(storeName);
            if (myNedbConnection != null)
                resolve(myNedbConnection);
            else {
                let myNedbConnectionMap = db_connections_1.myAppConnectionMap.getConnection(this.connectionName);
                myNedbConnectionMap.openConnection(storeName)
                    .then((msg) => { resolve(this.nedBMap().get(storeName)); })
                    .catch((err) => reject(err));
            }
        });
    }
    nedbForCurrentCollectionOrStore() {
        return this.nedbForCollectionOrStore(this.collectionName);
    }
    buildQueryByIdOfEntity(dataObj) {
        return this.buildQueryById(this.idHelper.extractId(dataObj));
    }
    buildQueryById(id) {
        let query = null;
        let mongoIdAsString = id;
        if (this.idHelper.isAuto()) {
            query = { '_id': /*new ObjectID(*/ mongoIdAsString /*)*/ };
        }
        else {
            query = { '_id': mongoIdAsString };
            //.id in mongoDB is an alias for .code or .id or .num in persistent entity
        }
        return query;
    }
    adjustEntitiesId(entities) {
        if (this.idHelper.getIdPropName() != "_id") {
            for (let e of entities) {
                this.adjustEntityId(e);
            }
        }
        return entities;
    }
    adjustEntityId(e) {
        if (this.idHelper.getIdPropName() != "_id") {
            //remplacer .id="valeurPk" par .idPropName="valeurPk":  
            let id = Reflect.get(e, "_id");
            Reflect.set(e, this.idHelper.getIdPropName(), id);
            Reflect.deleteProperty(e, "_id");
        }
        return e;
    }
    adjustMongoId(e) {
        if (this.idHelper.getIdPropName() != "_id") {
            //remplacer  .idPropName="valeurPk" par   .id="valeurPk" :
            let pkValue = Reflect.get(e, this.idHelper.getIdPropName());
            Reflect.set(e, "_id", pkValue);
            Reflect.deleteProperty(e, this.idHelper.getIdPropName());
        }
        return e;
    }
    adjustMongoIdForInsert(e) {
        e = this.adjustMongoId(e); //remplace si besoin .pkName par ._id
        //contrairement à MongoDB, Nedb va auto générer le _id
        //que si l'attibut _id n'existe pas (il ne faut pas null mais pas de _id du tout)
        if (this.idHelper.isAuto()) {
            let pkValue = Reflect.get(e, "_id");
            if (pkValue == null)
                Reflect.deleteProperty(e, "_id");
        }
        return e;
    }
    insert(dataObj) {
        return new Promise((resolve, reject) => {
            this.nedbForCurrentCollectionOrStore().then((nedb) => {
                nedb
                    .insert(this.adjustMongoIdForInsert(dataObj), (err, result) => {
                    if (err != null) {
                        console.log("genericInsert error = " + err);
                        if (err.name == 'uniqueViolated')
                            reject(new errorWithStatus_1.ConflictError("insertOne conflict exception (duplicate primary key)  " + JSON.stringify(dataObj)));
                        else
                            reject(new errorWithStatus_1.ErrorWithStatus("insertOne exception with =" + JSON.stringify(dataObj) + " " + err.message));
                    }
                    else {
                        //console.log() ???
                        resolve(this.adjustEntityId(result));
                    }
                }); //end of insertOne
            }); //end of this.dB().then()
        }); //end of Promise
    }
    saveOrUpdate(dataObj) {
        //console.log("in saveOrUpdate() , dataObj="+JSON.stringify(dataObj));
        let id = this.idHelper.extractId(dataObj);
        //console.log("in saveOrUpdate() , id="+id);
        if (this.idHelper.isAuto() && id == null) {
            return this.insert(dataObj);
        }
        else {
            //NB: autre solution: coder et appeler un update() with upsert option.
            return new Promise((resolve, reject) => {
                this.findById(id)
                    .then((existingEntityToUpdate) => {
                    //console.log("existing - need to be updated");
                    this.update(dataObj).then((res) => { resolve(res); })
                        .catch((err) => { reject(err); });
                })
                    .catch((notFoundErr) => {
                    //console.log("non existing - need to be inserted");
                    this.insert(dataObj).then((res) => { resolve(res); })
                        .catch((err) => { reject(err); });
                });
            });
        }
    }
    update(dataObj) {
        let query = this.buildQueryByIdOfEntity(dataObj);
        let changes = JSON.parse(JSON.stringify(dataObj)); //clonage
        Reflect.deleteProperty(changes, this.idHelper.getIdPropName()); //id/pk immutable (cannot change)
        return new Promise((resolve, reject) => {
            this.nedbForCurrentCollectionOrStore().then((nedb) => {
                nedb
                    .update(query, { $set: changes }, {}, (err, nbReplaced) => {
                    if (err != null) {
                        console.log("genericUpdate error = " + err);
                        reject(new errorWithStatus_1.ErrorWithStatus("updateOne exception with dataObj=" + JSON.stringify(dataObj)));
                    }
                    else {
                        if (nbReplaced == 1)
                            resolve(dataObj);
                        else
                            reject(new errorWithStatus_1.NotFoundError("updateOne exception with dataObj=" + JSON.stringify(dataObj)));
                    }
                }); //end of updateOne
            }); //end of this.dB().then()
        }); //end of Promise
    }
    findById(id) {
        let query = this.buildQueryById(id);
        return this.findOne(query);
    }
    findOne(query) {
        return new Promise((resolve, reject) => {
            this.nedbForCurrentCollectionOrStore().then((nedb) => {
                nedb.findOne(query, (err, item) => {
                    if (err != null) {
                        console.log("genericFindOne error = " + err);
                        reject(new errorWithStatus_1.NotFoundError("not found (query=" + JSON.stringify(query) + ")"));
                    }
                    else { //NB: item may be null if not found
                        if (item)
                            resolve(this.adjustEntityId(item));
                        else
                            reject(new errorWithStatus_1.NotFoundError("not found (query=" + JSON.stringify(query) + ")"));
                    }
                }); //end of findOne
            }); //end of this.dB().then()
        }); //end of Promise
    }
    findList(query) {
        return new Promise((resolve, reject) => {
            this.nedbForCurrentCollectionOrStore().then((nedb) => {
                nedb.find(query, (err, arr) => {
                    if (err != null) {
                        console.log("genericfindList error = " + err);
                        reject(new errorWithStatus_1.ErrorWithStatus("findList exception with query=" + query));
                    }
                    else {
                        resolve(this.adjustEntitiesId(arr));
                    }
                }); //end of find
            }); //end of this.....then()
        });
    }
    findAll() {
        return this.findList({});
    }
    remove(query) {
        return new Promise((resolve, reject) => {
            this.nedbForCurrentCollectionOrStore().then((nedb) => {
                nedb
                    .remove(query, function (err, numRemoved) {
                    if (err != null) {
                        console.log("genericRemove error = " + err);
                        reject(new errorWithStatus_1.ErrorWithStatus("remove exception with query=" + query));
                    }
                    else {
                        console.log(numRemoved + " document(s) deleted");
                        resolve();
                    }
                }); //end of remove
            }); //end of this.dB().then()
        }); //end of Promise
    }
    deleteById(id) {
        let query = this.buildQueryById(id);
        return new Promise((resolve, reject) => {
            this.nedbForCurrentCollectionOrStore().then((nedb) => {
                nedb
                    .remove(query, function (err, numRemoved) {
                    if (err != null) {
                        console.log("genericDeleteById error = " + err);
                        reject(new errorWithStatus_1.ErrorWithStatus("deleteOne exception / internal error"));
                    }
                    else {
                        //console.log(numRemoved + " document deleted");
                        if (numRemoved == 1)
                            resolve();
                        else
                            reject(new errorWithStatus_1.NotFoundError("deleteOne exception with id=" + id));
                    }
                }); //end of deleteOne
            }); //end of this.dB().then()
        }); //end of Promise
    }
}
exports.GenericNedbDataService = GenericNedbDataService;
