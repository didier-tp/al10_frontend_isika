"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GenericMongoDataService = void 0;
const IdHelper_1 = require("../../itf/generic/IdHelper");
const errorWithStatus_1 = require("../../../error/errorWithStatus");
const mongodb_1 = require("mongodb");
const GenericMongoConnection_1 = require("./GenericMongoConnection");
class GenericMongoDataService {
    //collectionName must be  replaced/override in subclass:
    // idHelper may be replaced/override in subclass:
    //by default _id (auto generated by mongoDB)
    //may be overrided by static _id (copy_or_renaming of .num or .code)
    constructor(collectionName, idHelper = new IdHelper_1.Auto_IdHelper()) {
        this.collectionName = collectionName;
        this.idHelper = idHelper;
        this.collectionName = collectionName;
    }
    //dbB() = utility function for accessing mongoDB connection already initialized or not
    dB() {
        return new Promise((resolve, reject) => {
            let myMongoConnection = GenericMongoConnection_1.MyMongoConnection.getInstance();
            if (myMongoConnection.isInitialized())
                resolve(myMongoConnection.currentDb());
            else {
                myMongoConnection.openConnection()
                    .then((msg) => { resolve(myMongoConnection.currentDb()); })
                    .catch((err) => reject(err));
            }
        });
    }
    buildQueryByIdOfEntity(dataObj) {
        return this.buildQueryById(this.idHelper.extractId(dataObj));
    }
    buildQueryById(id) {
        let query = null;
        let mongoIdAsString = id;
        if (this.idHelper.isAuto()) {
            query = { '_id': new mongodb_1.ObjectID(mongoIdAsString) };
        }
        else {
            query = { '_id': mongoIdAsString };
            //.id in mongoDB is an alias for .code or .id or .num in persistent entity
        }
        return query;
    }
    adjustEntitiesId(entities) {
        if (this.idHelper.getIdPropName() != "_id") {
            for (let e of entities) {
                this.adjustEntityId(e);
            }
        }
        return entities;
    }
    adjustEntityId(e) {
        if (this.idHelper.getIdPropName() != "_id") {
            //remplacer .id="valeurPk" par .idPropName="valeurPk":  
            let id = Reflect.get(e, "_id");
            Reflect.set(e, this.idHelper.getIdPropName(), id);
            Reflect.deleteProperty(e, "_id");
        }
        return e;
    }
    adjustMongoId(e) {
        if (this.idHelper.getIdPropName() != "_id") {
            //remplacer  .idPropName="valeurPk" par   .id="valeurPk" :
            let pkValue = Reflect.get(e, this.idHelper.getIdPropName());
            Reflect.set(e, "_id", pkValue);
            Reflect.deleteProperty(e, this.idHelper.getIdPropName());
        }
        return e;
    }
    insert(dataObj) {
        return new Promise((resolve, reject) => {
            this.dB().then((db) => {
                db.collection(this.collectionName)
                    .insertOne(this.adjustMongoId(dataObj), (err, result) => {
                    if (err != null) {
                        console.log("genericInsert error = " + err);
                        if (err.code == 11000)
                            reject(new errorWithStatus_1.ConflictError("insertOne conflict exception (duplicate primary key)  " + JSON.stringify(dataObj)));
                        else
                            reject(new errorWithStatus_1.ErrorWithStatus("insertOne exception with =" + JSON.stringify(dataObj) + " " + err.message + " " + err.code));
                    }
                    else {
                        //console.log() ???
                        resolve(this.adjustEntityId(dataObj));
                    }
                }); //end of insertOne
            }); //end of this.dB().then()
        }); //end of Promise
    }
    saveOrUpdate(dataObj) {
        //console.log("in saveOrUpdate() , dataObj="+JSON.stringify(dataObj));
        let id = this.idHelper.extractId(dataObj);
        //console.log("in saveOrUpdate() , id="+id);
        if (this.idHelper.isAuto() && id == null) {
            return this.insert(dataObj);
        }
        else {
            //NB: autre solution: coder et appeler un update() with upsert option.
            return new Promise((resolve, reject) => {
                this.findById(id)
                    .then((existingEntityToUpdate) => {
                    //console.log("existing - need to be updated");
                    this.update(dataObj).then((res) => { resolve(res); })
                        .catch((err) => { reject(err); });
                })
                    .catch((notFoundErr) => {
                    //console.log("non existing - need to be inserted");
                    this.insert(dataObj).then((res) => { resolve(res); })
                        .catch((err) => { reject(err); });
                });
            });
        }
    }
    update(dataObj) {
        let query = this.buildQueryByIdOfEntity(dataObj);
        let changes = JSON.parse(JSON.stringify(dataObj)); //clonage
        Reflect.deleteProperty(changes, this.idHelper.getIdPropName()); //id/pk immutable (cannot change)
        return new Promise((resolve, reject) => {
            this.dB().then((db) => {
                db.collection(this.collectionName)
                    .updateOne(query, { $set: changes }, (err, obj) => {
                    if (err != null) {
                        console.log("genericUpdate error = " + err);
                        reject(new errorWithStatus_1.ErrorWithStatus("updateOne exception with dataObj=" + JSON.stringify(dataObj)));
                    }
                    else {
                        if (obj.result.n == 1)
                            resolve(dataObj);
                        else
                            reject(new errorWithStatus_1.NotFoundError("updateOne exception with dataObj=" + JSON.stringify(dataObj)));
                    }
                }); //end of updateOne
            }); //end of this.dB().then()
        }); //end of Promise
    }
    findById(id) {
        let query = this.buildQueryById(id);
        return this.findOne(query);
    }
    findOne(query) {
        return new Promise((resolve, reject) => {
            this.dB().then((db) => {
                db.collection(this.collectionName)
                    .findOne(query, (err, item) => {
                    if (err != null) {
                        console.log("genericFindOne error = " + err);
                        reject(new errorWithStatus_1.NotFoundError("not found (query=" + JSON.stringify(query) + ")"));
                    }
                    else { //NB: item may be null if not found
                        if (item)
                            resolve(this.adjustEntityId(item));
                        else
                            reject(new errorWithStatus_1.NotFoundError("not found (query=" + JSON.stringify(query) + ")"));
                    }
                }); //end of findOne
            }); //end of this.dB().then()
        }); //end of Promise
    }
    findList(query) {
        return new Promise((resolve, reject) => {
            this.dB().then((db) => {
                var cursor = db.collection(this.collectionName).find(query);
                cursor.toArray((err, arr) => {
                    if (err != null) {
                        console.log("genericfindList error = " + err);
                        reject(new errorWithStatus_1.ErrorWithStatus("findList exception with query=" + query));
                    }
                    else {
                        resolve(this.adjustEntitiesId(arr));
                    }
                }); //end of toArray
            }); //end of this.dB().then()
        });
    }
    findAll() {
        return this.findList({});
    }
    remove(query) {
        return new Promise((resolve, reject) => {
            this.dB().then((db) => {
                db.collection(this.collectionName)
                    .remove(query, function (err, obj) {
                    if (err != null) {
                        console.log("genericRemove error = " + err);
                        reject(new errorWithStatus_1.ErrorWithStatus("remove exception with query=" + query));
                    }
                    else {
                        console.log(obj.result.n + " document(s) deleted");
                        resolve();
                    }
                }); //end of remove
            }); //end of this.dB().then()
        }); //end of Promise
    }
    deleteById(id) {
        let query = this.buildQueryById(id);
        return new Promise((resolve, reject) => {
            this.dB().then((db) => {
                db.collection(this.collectionName)
                    .deleteOne(query, function (err, obj) {
                    if (err != null) {
                        console.log("genericDeleteById error = " + err);
                        reject(new errorWithStatus_1.ErrorWithStatus("deleteOne exception / internal error"));
                    }
                    else {
                        //console.log(obj.result.n + " document deleted");
                        if (obj.result.n == 1)
                            resolve();
                        else
                            reject(new errorWithStatus_1.NotFoundError("deleteOne exception with id=" + id));
                    }
                }); //end of deleteOne
            }); //end of this.dB().then()
        }); //end of Promise
    }
}
exports.GenericMongoDataService = GenericMongoDataService;
